{#
    This file is part of the CloudStack Client Generator.

    (c) Quentin Plepl√© <quentin.pleple@gmail.com>
    (c) Aaron Hurt <ahurt@anbcs.com>
    (c) Nathan Johnson <nathan@nathanjohnson.info>
    (c) Daniel Carbone <daniel.p.carbone@gmail.com>
    (c) Bogdan Gabor <bgabor@ena.com>

    For the full copyright and license information, please view the LICENSE
    file that was distributed with this source code.
#}{% spaceless %}
{% set params = api.parameters %}
{% set requiredParams = params.required %}
{% set optionalParams = params.optional %}
{% set requiredParamLength = requiredParams|length %}
{% set optionalParamLength = optionalParams|length %}
{% set hasMapParameter = false %}
{% for param in api.parameters if hasMapParameter == false %}
    {% if param.type == 'map' %}
        {% set hasMapParameter = true %}
    {% endif %}
{% endfor %}
{% endspaceless %}
<?php

{{ namespace_stmt('CloudStackRequest') }}

{{ file_header(capabilities) }}
{% if 0 < requiredParamLength %}

use {{ namespace_path('CloudStackRequestException') }};{% endif %}{% if namespace_path() != '' %}{% if api.isAsync and api.eventType != ''%}

use {{ namespace_path('CloudStackEventTypes') }};{% endif %}{% if hasMapParameter %}

use {{ namespace_path('CloudStackHelpers') }};{% endif %}

{% endif %}

/**
{{ swagger_definition_tag(api.swaggername, escape_swagger_string(api.description), api.parameters, 0) }}
 */

/**
 * Class {{ api.requestClassname }}
 * @package {{ namespace_path('CloudStackRequest', true) }}
{{ since_tag_line(api.since, 0, true) }} */
class {{ api.requestClassname }} implements CloudStackRequestInterface, CloudStackApiCommandRequest{% if api.isList %}, CloudStackListRequest{% endif %}{% if api.isAsync %}, CloudStackAsynchronousRequest{% else %}, CloudStackSynchronousRequest{% endif %}{% if api.isCacheable %}, CloudStackCacheableRequest{% endif %}

{
{% if api.isAsync %}
    const EVENT_TYPE = {% if api.eventType == '' %}''{% else %}CloudStackEventTypes::{{ api.eventType }}{% endif %};
{% endif %}
    const COMMAND_NAME = '{{ api.name }}';
{% if requiredParamLength > 0 or optionalParamLength > 0 %}

{% for prop in api.parameters %}
{{ prop.propertyDocBloc }}
    private ${{ prop.name }};

{% endfor %}{% endif %}{% if api.isCacheable %}
    /**
     * If true, allows the response to be pulled from cache rather than being executed against ACS
     * @var bool
     */
    private $cachedResponseAllowed = {{ env.cache.commandEnabled(api.name) ? 'true' : 'false' }};

    /**
     * If true, allows the response from this request to be put in the cache
     * @var bool
     */
    private $responseCachingEnabled = {{ env.cache.commandEnabled(api.name) ? 'true' : 'false' }};

    /**
     * The duration this request's response is cached, if caching is allowed for this request
     * @var int
     */
    private $responseCacheTTL = {{ env.cache.commandTTL(api.name) }};

{% endif %}{% if requiredParamLength > 0 or optionalParamLength > 0 %}
    /**
     * {{ api.requestClassname }} Constructor
     *
{% for param in requiredParams %}
     * @param {{ param.PHPTypeTagValue }} ${{ param.name }} {{ param.description|raw|ucfirst }}
{% endfor %}
{% if optionalParamLength > 0 %}
     * @param array $optArgs {
{# document all optional paramaters #}
{% for param in optionalParams %}
     *     @type {{ param.PHPTypeTagValue }} ${{ param.name }} {{ param.description|raw|ucfirst }}
{% endfor %}
{# end optional arguments #}
     * }
{% endif %}
{% if api.isCacheable %}
     * @param bool $useCachedResponse Whether to allow the use of a previously cached response for this specific request
     * @param bool $enableResponseCaching Whether to allow the response from this specific request to be cached for later use
     * @param int $cacheTTL Time in seconds to cache response, if allowed
{% endif %}
     */
    public function __construct ({% for param in requiredParams %}{{ loop.index0 > 0 ? ', ' : '' }}{% if 'array' == param.phpType %}array {% endif %}${{ param.name }}{% endfor %}
{# end required #}
{# append optional arguments if needed #}
{% if optionalParamLength > 0 %}{% if requiredParamLength > 0 %}, {% endif %}array $optArgs = []{% endif %}
{% if api.isCacheable %}{% if requiredParamLength > 0 or optionalParamLength > 0 %}, {% endif %}bool $useCachedResponse = {{ env.cache.isCommandEnabled(api.name) ? 'true' : 'false' }}, bool $enableResponseCaching = {{ env.cache.isCommandEnabled(api.name) ? 'true' : 'false' }}, int $cacheTTL = {{ env.cache.commandTTL(api.name) }}{% endif %})
    {
{% for param in requiredParams %}
        $this->set{{ param.name|capitalize }}(${{ param.name }});
{% endfor %}{% if 0 != optionalParamLength %}
        foreach($optArgs as $k => $v) {
            $this->{'set'.ucfirst($k)}($v);
        }
{% endif %}{% if api.isCacheable %}
        $this->cachedResponseAllowed = $useCachedResponse;
        $this->responseCachingEnabled = $enableResponseCaching;
        $this->responseCacheTTL = $cacheTTL;
{% endif %}
    }
{% endif %}

    /**
     * @param array $data
     * @return {{ namespace_path('CloudStackRequest\\' ~ api.requestClassname, true) }}
     */
    public static function fromArray(array $data = []): {{ api.requestClassName }}
    {
{% if requiredParamLength == 0 and optionalParamLength == 0 %}
        return new static;
{% elseif 0 == requiredParamLength %}{# this object only contains optional parameters #}
        return new static($data);
{% else %}{% for param in requiredParams %}
        if (isset($data['{{ param.name }}'])) {
            ${{ param.name }} = $data['{{ param.name }}'];
            unset($data['{{ param.name }}']);
        } else {
            throw new \DomainException('{{ api.requestClassname }}::fromArray - Required parameter "{{ param.name }}" not found in $data.');
        }

{% endfor %}
        $n = new static({% for param in requiredParams %}{{ loop.index0 > 0 ? ',' : '' }}
            ${{ param.name }}{% endfor %}{% if optionalParamLength > 0 %}{% if requiredParamLength > 0 %},
{% endif %}
            $data{% endif %}

        );

        return $n;
{% endif %}
    }

{% for prop in api.parameters %}
{% include "models/getter.php.twig" with {'prop': prop, 'env': env} %}


{% include "models/setter.php.twig" with {'api': api, 'prop': prop, 'env': env} %}


{% endfor %}
    /**
     * @return string
     */
    public function getCloudStackCommandParameter(): string
    {
        return 'command';
    }

    /**
     * @return string
     */
    public function getCloudStackCommandName(): string
    {
        return self::COMMAND_NAME;
    }

    /**
     * @return string
     */
    public function getCloudStackResponseModel(): string
    {
        return '{{ api.response.FQName|replace({"\\": "\\\\"}) }}';
    }
{% if api.isAsync %}

    /**
     * @return string
     */
    public function getCloudStackEventType(): string
    {
        return self::EVENT_TYPE;
    }
{% endif %}

    /**
     * @return bool
     */
    public function isRequestValid(): bool
    {
{% if 0 == requiredParamLength %}
        // all parameters are optional
        return true;{% else %}
        return isset($this->{{ requiredParams|keys|join(")\n            && isset($this->") }});{% endif %}

    }

    /**
     * @throws {{ namespace_path('CloudStackRequestException', true) }}
     */
    public function validateRequest(): void
    {
{% if 0 == requiredParamLength %}
        // all parameters are optional
{% else %}
        $errors = [];
{% for param in requiredParams %}
        if (!isset($this->{{ param.name }})) {
            $errors[] = 'Required parameter "{{ param.name }}" is not set';
        }
{% endfor %}
        if (0 < count($errors)) {
            throw new CloudStackRequestException($this, $errors);
        }
{% endif %}
    }

    /**
     * @return array
     */
    public function toUrlParams(): array
    {
        $a = [];
{% for param in api.parameters %}
{% if 'map' == param.type %}
        if (isset($this->{{ param.name }}) && is_array($this->{{ param.name }}) && count($this->{{ param.name }}) > 0) {
            foreach(CloudStackHelpers::formatCSQueryArray($this->{{ param.name }}, '{{ param.name }}') as $k => $v) {
                $a[$k] = $v;
            }
        }
{% elseif 'array' == param.phpType %}
        if (isset($this->{{ param.name }})) {
            $a['{{ param.name }}'] = implode(',', $this->{{ param.name }});
        }
{% elseif 'boolean' == param.phpType %}
        if (isset($this->{{ param.name }})) {
            $a['{{ param.name }}'] = $this->{{ param.name }} ? 'true' : 'false';
        }
{% else %}
        if (isset($this->{{ param.name }})) {
            $a['{{ param.name }}'] = (string)$this->{{ param.name }};
        }
{% endif %}
{% endfor %}
        return $a;
    }{% if api.isCacheable %}


    /**
     * Specify whether this request is allowed to use the response cache
     * @param bool $allow
     */
    public function setAllowCachedResponse(bool $allow): void
    {
        $this->cachedResponseAllowed = $allow;
    }

    /**
     * If true, the client will attempt to pull the response for this request from cache
     * @return bool
     */
    public function getCachedResponseAllowed(): bool
    {
        return $this->cachedResponseAllowed;
    }

    /**
     * Specifies that the response from this request may not be put into the cache
     * @param bool $enable
     */
    public function setEnableResponseCaching(bool $enable): void
    {
        $this->responseCachingEnabled = $enable;
    }

    /**
     * If true, the response from this request may not be cached.
     * @return bool
     */
    public function getResponseCachingEnabled(): bool
    {
        return $this->responseCachingEnabled;
    }

    /**
     * The duration in seconds the response for this request may be cached, if allowed
     * @return int
     */
    public function getResponseCacheTTL(): int
    {
        return $this->responseCacheTTL;
    }

    /**
     * Specifies the number of seconds this specific request's response maybe cached for, if allowed
     * @param int $ttl
     */
    public function setResponseCacheTTL(int $ttl): void
    {
        $this->responseCacheTTL = $ttl;
    }{% endif %}


    /**
     * @return array
     */
    public function jsonSerialize()
    {
        $a = [];
{% for param in api.parameters %}
        if (isset($this->{{ param.name }}){% if param.isCollection %} && is_array($this->{{ param.name }}) && count($this->{{ param.name }}) > 0{% endif %}) {
            $a['{{ param.name }}'] = $this->{{ param.name }};
        }
{% endfor %}
        return $a;
    }
}